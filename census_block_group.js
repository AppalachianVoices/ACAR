/*
 * And finally, a script that nobody will ever use that does the same analysis as the first script, but by census block group rather than 1-mile buffer around communities:
 * https://ee-api.appspot.com/11bb16e4b9bec9800f6270b4501350fa
 */

/*
00 ACAR - Block Group Analysis

This Script generates a full analysis by county of mined areas
and distance to mining for communities in the "Appalachian 
Communities at Risk" application for iLoveMountains.org
*/

var CountySelect = 'KY-Perry';
var census_year = 1990;
var start_year = 1984;
var end_year = 2014;
var metersToMile = 1609;
var NDVI_Threshold = 0.4;
var minMTRsize = 25000; //in meters-squared
var maskBufferSize = "120m"; //Select either 60m or 120m

/*
Select a county and create a 1-mile buffer around it. Then convert 
buffered county back to a geometry to use later with filterBounds()
*/

var CountyFC = 
  ee.FeatureCollection(
    'ft:1v5OEHqR7rg425zEMjCYiCZLnWkZEP4clwZG2btvZ');

var County = CountyFC.filterMetadata('State-County', 'equals', CountySelect);
var FlatCounty = ee.Feature(County.geometry(25));
var CountyBuffer = FlatCounty.buffer(metersToMile);
var CountyBufferGeo = CountyBuffer.geometry(25);
var CountyGeo = County.geometry(25);

var PopPlaces = 
  ee.FeatureCollection(
    'ft:19h17oltHKf-X4OfU7jN1EPHsG1pF-yFfP06gt236'); 
var place_distance = PopPlaces.distance(10000);


/* 
Load the mask created by Skytruth of roads, rivers and urban areas
in order to segregate mined areas from developed areas in valleys that
have similar NDVI signatures. To minimize the inadvertent masking out of
legitimate mined areas next to roads and streams, eliminate areas 
that have been permitted for mining from the mask by adding them to a
reverse mask of the image generated by Skytruth
*/

if (maskBufferSize == "60m") {
    var mask_input = ee.Image('GME/images/06136759344167181854-02242958771191394493');
} else {
    var mask_input = ee.Image('GME/images/06136759344167181854-05713571480559172508');
}

var mask_clipped = mask_input.clip(CountyBuffer); 
var mask_result = mask_clipped .mask(mask_clipped ); 
var mask_reverse = mask_clipped .mask(mask_clipped .not()); 

var state_choice = CountySelect.substring(0,2);
switch (state_choice) {
    case "VA":
      
      var VAPermitsFC = ee.FeatureCollection('ft:1MknTcoX0btJo6gzwINgrN3HrmlwluzpZiH_PObwS').filterBounds(CountyBufferGeo);
      var masklayer = mask_reverse
        .paint(VAPermitsFC); 
      break;
      
    case "WV":
      var WVPermitsFC = ee.FeatureCollection('ft:1YMS8TVLWE7rdyC1088Dyl4HoOioctEoYEcM9bwgN').filterBounds(CountyBufferGeo);
      var WVValleyFillsFC = ee.FeatureCollection('ft:1Jijn5Rpli1Ar2OLBePO1fXzzyhnH5mwBgCcoRTFB').filterBounds(CountyBufferGeo);
      var masklayer = mask_reverse
        .paint(WVPermitsFC)
        .paint(WVValleyFillsFC); 
      break;
      
    case "KY":
      var KYPermits_Pikeville = ee.FeatureCollection('ft:1M2uV2lbzh5uSDMTvdTbmKNcgZjrdcCZuDhV6yf_2').filterBounds(CountyBufferGeo);
      var KYPermits_Prestonsburg = ee.FeatureCollection('ft:1XxFmwbnE37npHevIP0_jqDQxoYT0mJ7p3ZKpzf7D').filterBounds(CountyBufferGeo);
      var KYPermits_Middlesboro = ee.FeatureCollection('ft:1w8tAUGj3-tBbK_gAJgU2ApcxCBjSAPx2du8te24v').filterBounds(CountyBufferGeo);
      var KYPermits_London = ee.FeatureCollection('ft:1Up36JNWJldNZ5il8mMn-eC54Un6E2pGXbSBSw3d8').filterBounds(CountyBufferGeo);
      var masklayer = mask_reverse
        .paint(KYPermits_Pikeville)
        .paint(KYPermits_Middlesboro)
        .paint(KYPermits_London)
        .paint(KYPermits_Prestonsburg); 
      break;

    case "TN":
      var ActivePermitsFC = ee.FeatureCollection('ft:1Fj2bNu-11Gr5eMsdkshtoLqg6P4u6XoJSEIzBrhG').filterBounds(CountyBufferGeo);
      var InactivePermitsFC = ee.FeatureCollection('ft:1gd2y5e8D9jm0A8T75hwqnVFbheZdzReNIpysqQP6').filterBounds(CountyBufferGeo);
      var masklayer = mask_reverse
        .paint(ActivePermitsFC)
        .paint(InactivePermitsFC); 
      break;
}

/*
Get the layer of populated places and filter it to the actual 
boundaries of the county. Then create a function to calculate 1-mile 
buffers around each community.
*/

switch (census_year) {
    case 1990:
        switch (state_choice) {
            case "WV":
                var BlockGroups = ee.FeatureCollection('ft:1jYnWUeyLF_j2vw10lnnkJetjUjYH_6fYY4K3nq7c'); 
            break;
            case "KY":
                var BlockGroups = ee.FeatureCollection('ft:1S7oGVBs9TVA6nr21-ib6Z9l0418Ih9LRJvnxgwex'); 
            break;
            case "VA":
                var BlockGroups = ee.FeatureCollection('ft:1iri8t2-h4TAZQYtdq_6t429GOy_-rp454ZTki_U3'); 
            break;
        }
      break;
      
    case 2000:
        switch (state_choice) {
            case "WV":
                var BlockGroups = ee.FeatureCollection('ft:143Tq4RFxmAQCtD6T8ctR47SM6rjN94XvGiXvbAw_'); 
            break;
            case "KY":
                var BlockGroups = ee.FeatureCollection('ft:1F9_Ko7UV6wFJ9E2k91hZD3gzOFp4QBaSEfypxt6p'); 
            break;
            case "VA":
                var BlockGroups = ee.FeatureCollection('ft:1-SM7DAazk5F7AF_BJ0sFG0xxfx2KW6rdQggwIDZJ'); 
            break;
        }
      break;

    case 2010:
        switch (state_choice) {
            case "WV":
                var BlockGroups = ee.FeatureCollection('ft:1gV7xjPcVc7s8J2pt_MdeN85a2lX-UXSxaAAm4I6e'); 
            break;
            case "KY":
                var BlockGroups = ee.FeatureCollection('ft:1nSs8ljDe5XNgMEoCr2V9ADuOyD1s71bbqZDGllgU'); 
            break;
            case "VA":
                var BlockGroups = ee.FeatureCollection('ft:1LP-S4QlgWqZxDe2AnEZE7DhIbjF41SBPX5cYjFQg'); 
            break;
        }
      break;
}

var FilteredBlockGroups = BlockGroups.filterMetadata('County', 'equals', CountySelect);

/* Create functions and initialize arrays used in loop */

var MineArea = function(f) {
    return f.set({area: f.area(1000), 'year':NDVI_Year, 'county':CountySelect});
};

var differ = function( feature ){
    return feature
      .set({'total_area': feature.area(1000)})
      .difference(flatMTR, 25);
};

var area_er = function( feat ){
    var area = feat.area(25);
    return feat.set({'unmined_area':area, 'year':NDVI_Year, 'county':CountySelect});
};

var areas_list = [];
var LargeMTR_list = [];

/*
Create a greenest pixel LANDSAT composite for the selected year, 
clip it to a 1-mile buffer around the selected county and 
calculate NDVI values from the greenest pixel composite. 
*/

for(var NDVI_Year = start_year; NDVI_Year <= end_year; NDVI_Year = NDVI_Year +3){

    if (NDVI_Year < 2012) {
      var composite = ee.Image(ee.ImageCollection('LANDSAT/LT5_L1T_ANNUAL_GREENEST_TOA')
        .filterDate( NDVI_Year + '-01-01', NDVI_Year + '-12-31')
        .first());
      var clip_composite = composite.clip(CountyBuffer);
      var gp_ndvi = clip_composite.expression(
        '(nir - red) / (nir + red)',
        {
            red: clip_composite.select('B3'),
            nir: clip_composite.select('B4')
        });
      var NDVI_val = gp_ndvi.select('B4'); 
      
    } else {
      
      var composite = ee.Image(ee.ImageCollection('LANDSAT/LC8_L1T_ANNUAL_GREENEST_TOA')
        .filterDate( NDVI_Year + '-01-01', NDVI_Year + '-12-31')
        .first());
      var clip_composite = composite.clip(CountyBuffer);
      var gp_ndvi = clip_composite.expression(
       '(nir - red) / (nir + red)',
        {
            red: clip_composite.select('B4'),
            nir: clip_composite.select('B5')
        });
      var NDVI_val = gp_ndvi.select('B5'); 
    }

/* 
Construct a binary layer of NDVI values that are below the threshold 
set previously and add it to map. This layer will include both active 
mining and developed (i.e. urban) areas with low NDVI signatures.
Then create a vector layer from the image of mined areas and
create a "sieve" routine to eliminate small patches of low-NDVI
pixels from urban development that escaped the masking routine 
or roads on reclaimed mine sites that do not actually
represent active surface mining.
*/

    var blank = ee.Image(0);
    var output = blank.where(NDVI_val.lte(NDVI_Threshold), 1); 
    var LowNDVIresult = output.mask(output); 

    var MTRresult = LowNDVIresult.and(masklayer);
    var MTR_vectors = MTRresult.reduceToVectors(null, CountyGeo, 25);
    var MTR_Area = MTR_vectors.map(MineArea);

    LargeMTR_list[NDVI_Year] = MTR_Area.filterMetadata('area', 'greater_than', minMTRsize);

/*
Subtract the active mining layer from the buffered communities 
in order to calculate the unmined area within a 1-mile radius 
of each community. Then run functions to calculate 
the nearest distance to active mining and area within a 1-mile 
radius that is NOT classified as active mining
*/

    var flatMTR = ee.Feature(LargeMTR_list[NDVI_Year].geometry(25));
    var NoMTRinBG = FilteredBlockGroups.map( differ );
    areas_list[NDVI_Year] = NoMTRinBG.map( area_er );

    if (census_year == 2010) {
        var flatMTRgeo = flatMTR.geometry(25);
        var clip_distance = place_distance.clip(flatMTRgeo);
        var mean_distance = clip_distance.reduceRegion(ee.Reducer.mean(), flatMTRgeo, 25);
        print(mean_distance.getInfo().distance);  
    }
    
    Map.addLayer(LargeMTR_list[NDVI_Year], {color: 'FF0000'}, 'Active Surface Mining: ' + NDVI_Year);
}

var areas_FC = ee.FeatureCollection(areas_list[start_year]);
// var LargeMTR_FC = ee.FeatureCollection(LargeMTR_list[start_year]);

for(var loop_Year = start_year + 3; loop_Year <= end_year; loop_Year = loop_Year +3){
  areas_FC = areas_FC.merge(areas_list[loop_Year]);
//  LargeMTR_FC = LargeMTR_FC.merge(LargeMTR_list[loop_Year]);
}

print(areas_FC.getDownloadURL('csv','year,total_area,unmined_area,GISJOIN,county', 'ACAR_' + CountySelect + '_' + start_year + '-' + end_year + '_BlockGroup_' + census_year));
// print(LargeMTR_FC.getDownloadURL('kml', null, 'ACAR_' + CountySelect + '_' + start_year + '-' + end_year +  '_ActiveMining_' + maskBufferSize));

// Add layers to map

Map.centerObject(FlatCounty, 11);

//Map.addLayer(clip_composite, {'bands':['B3', 'B2', 'B1'], min:0, max:0.25}, NDVI_Year + ' Greenest Pixel');
//Map.addLayer(gp_ndvi,{palette: 'FFFFFF, CE7E45, DF923D, F1B555, FCD163, 99B718, 74A901, 66A000, 529400, 3E8601, 207401, 056201, 004C00, 023B01, 012E01, 011D01, 011301'}, NDVI_Year + ' Greenest Pixel NDVI');
//Map.addLayer(LowNDVIresult, {palette: '0000FF'}, 'Low NDVI areas');
//Map.addLayer(MTRresult, {palette: 'FF00FF'}, 'Unsieved Surface Mining');
//Map.addLayer(mask_result, {palette: '000000'}, 'Original Mask');
//Map.addLayer(masklayer, {palette: '000000'}, 'Reverse Mask');
//Map.addLayer(LargeMTR, {color: 'FF0000'}, 'Active Surface Mining');
//Map.addLayer(LargeMTR_FC, {color: 'FF0000'}, 'Active Surface Mining');
Map.addLayer(FilteredBlockGroups, {color:'b0b0b0'}, "Block groups " + census_year);

