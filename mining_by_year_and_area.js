/*
The main script that generates the year-by-year mine maps and the Area-Distance data:
https://ee-api.appspot.com/fe1671c25116b6768d4f360ade75e099
*/

/*
00 ACAR - All States Analysis

This Script generates a full analysis by county of mined areas
and distance to mining for communities in the "Appalachian 
Communities at Risk" application for iLoveMountains.org
*/

var CountySelect = 'WV-Boone';
var start_year = 1984;
var end_year = 2014;
var metersToMile = 1609;
var NDVI_Threshold = 0.4;
var minMTRsize = 25000; //in meters-squared
var maskBufferSize = "120m"; //Select either 60m or 120m
var map_for_print = "no"; //clips mines to county boundaries, rather than 1-mile buffer needed for analysis

/*
Select a county and create a 1-mile buffer around it. Then convert 
buffered county back to a geometry to use later with filterBounds()
*/

var CountyFC = 
  ee.FeatureCollection(
    'ft:1v5OEHqR7rg425zEMjCYiCZLnWkZEP4clwZG2btvZ');

var County = CountyFC.filterMetadata('State-County', 'equals', CountySelect);
var FlatCounty = ee.Feature(County.geometry(25));
var CountyBuffer = FlatCounty.buffer(metersToMile);
var CountyBufferGeo = CountyBuffer.geometry(25);
var CountyGeo = County.geometry(25);

/* 
Load the mask created by Skytruth of roads, rivers and urban areas
in order to segregate mined areas from developed areas in valleys that
have similar NDVI signatures. To minimize the inadvertent masking out of
legitimate mined areas next to roads and streams, eliminate areas 
that have been permitted for mining from the mask by adding them to a
reverse mask of the image generated by Skytruth

New 120m: 06136759344167181854-05713571480559172508
Old 120m: 06136759344167181854-01480295612483575679

New 60m: 06136759344167181854-02242958771191394493
Old 60m: 06136759344167181854-08318853867614010871
*/

if (maskBufferSize == "60m") {
    var mask_input = ee.Image('GME/images/06136759344167181854-02242958771191394493');
} else {
    var mask_input = ee.Image('GME/images/06136759344167181854-05713571480559172508');
}

var mask_clipped = mask_input.clip(CountyBuffer); 
var mask_result = mask_clipped .mask(mask_clipped ); 
var mask_reverse = mask_clipped .mask(mask_clipped .not()); 

var state_choice = CountySelect.substring(0,2);
switch (state_choice) {
    case "VA":
      
      var VAPermitsFC = ee.FeatureCollection('ft:1MknTcoX0btJo6gzwINgrN3HrmlwluzpZiH_PObwS').filterBounds(CountyBufferGeo);
      var masklayer = mask_reverse
        .paint(VAPermitsFC); 
      break;
      
    case "WV":
      var WVPermitsFC = ee.FeatureCollection('ft:1YMS8TVLWE7rdyC1088Dyl4HoOioctEoYEcM9bwgN').filterBounds(CountyBufferGeo);
      var WVValleyFillsFC = ee.FeatureCollection('ft:1Jijn5Rpli1Ar2OLBePO1fXzzyhnH5mwBgCcoRTFB').filterBounds(CountyBufferGeo);
      var masklayer = mask_reverse
        .paint(WVPermitsFC)
        .paint(WVValleyFillsFC); 
      break;
      
    case "KY":
//      var KYPermits_Pikeville = ee.FeatureCollection('ft:1M2uV2lbzh5uSDMTvdTbmKNcgZjrdcCZuDhV6yf_2').filterBounds(CountyBufferGeo);
//      var KYPermits_Prestonsburg = ee.FeatureCollection('ft:1XxFmwbnE37npHevIP0_jqDQxoYT0mJ7p3ZKpzf7D').filterBounds(CountyBufferGeo);
      var KYPermits_Middlesboro = ee.FeatureCollection('ft:1w8tAUGj3-tBbK_gAJgU2ApcxCBjSAPx2du8te24v').filterBounds(CountyBufferGeo);
      var KYPermits_London = ee.FeatureCollection('ft:1Up36JNWJldNZ5il8mMn-eC54Un6E2pGXbSBSw3d8').filterBounds(CountyBufferGeo);
      var masklayer = mask_reverse
//paint(KYPermits_Pikeville)
        .paint(KYPermits_Middlesboro)
        .paint(KYPermits_London);
//        .paint(KYPermits_Prestonsburg) 
      break;

    case "TN":
      var ActivePermitsFC = ee.FeatureCollection('ft:1Fj2bNu-11Gr5eMsdkshtoLqg6P4u6XoJSEIzBrhG').filterBounds(CountyBufferGeo);
      var InactivePermitsFC = ee.FeatureCollection('ft:1gd2y5e8D9jm0A8T75hwqnVFbheZdzReNIpysqQP6').filterBounds(CountyBufferGeo);
      var masklayer = mask_reverse
        .paint(ActivePermitsFC)
        .paint(InactivePermitsFC); 
      break;
}

/*
Get the layer of populated places and filter it to the actual 
boundaries of the county. Then create a function to calculate 1-mile 
buffers around each community.
*/

var PopPlaces = 
  ee.FeatureCollection(
    'ft:19h17oltHKf-X4OfU7jN1EPHsG1pF-yFfP06gt236'); 

var FilteredPopPlaces = PopPlaces.filterBounds(County); 

var bufferer = function(feature) {
  var buffered = feature.buffer(metersToMile);
  return buffered;
}; 

var bufferedPlaces = FilteredPopPlaces.map(bufferer); 

/* Create functions and initialize arrays used in loop */

var MineArea = function(f) {
    return f.set({area: f.area(1000), 'year':NDVI_Year, 'county':CountySelect});
};

var differ = function( feature ){
    return feature.difference(flatMTR, 25);
};

var area_er = function( feat ){
    var area = feat.area(25);
    return feat.set({'area':area, 'year':NDVI_Year, 'county':CountySelect});
};

var dist_er = function( feat ){
    var dist = feat.distance(flatMTR, 25);
    return feat.set({'dist':dist, 'year':NDVI_Year, 'county':CountySelect});
};

var areas_list = [];
var distances_list = [];
var LargeMTR_list = [];
var printMTR_list = [];

/*
Create a greenest pixel LANDSAT composite for the selected year, 
clip it to a 1-mile buffer around the selected county and 
calculate NDVI values from the greenest pixel composite. 
*/

for(var NDVI_Year = start_year; NDVI_Year <= end_year; NDVI_Year = NDVI_Year +3){

    if (NDVI_Year < 2012) {
      var composite = ee.Image(ee.ImageCollection('LANDSAT/LT5_L1T_ANNUAL_GREENEST_TOA')
        .filterDate( NDVI_Year + '-01-01', NDVI_Year + '-12-31')
        .first());
      var clip_composite = composite.clip(CountyBuffer);
      var gp_ndvi = clip_composite.expression(
        '(nir - red) / (nir + red)',
        {
            red: clip_composite.select('B3'),
            nir: clip_composite.select('B4')
        });
      var NDVI_val = gp_ndvi.select('B4'); 
      
    } else {
      
      var composite = ee.Image(ee.ImageCollection('LANDSAT/LC8_L1T_ANNUAL_GREENEST_TOA')
        .filterDate( NDVI_Year + '-01-01', NDVI_Year + '-12-31')
        .first());
      var clip_composite = composite.clip(CountyBuffer);
      var gp_ndvi = clip_composite.expression(
       '(nir - red) / (nir + red)',
        {
            red: clip_composite.select('B4'),
            nir: clip_composite.select('B5')
        });
      var NDVI_val = gp_ndvi.select('B5'); 
    }

/* 
Construct a binary layer of NDVI values that are below the threshold 
set previously and add it to map. This layer will include both active 
mining and developed (i.e. urban) areas with low NDVI signatures.
Then create a vector layer from the image of mined areas and
create a "sieve" routine to eliminate small patches of low-NDVI
pixels from urban development that escaped the masking routine 
or roads on reclaimed mine sites that do not actually
represent active surface mining.
*/

    var blank = ee.Image(0);
    var output = blank.where(NDVI_val.lte(NDVI_Threshold), 1); 
    var LowNDVIresult = output.mask(output); 

    var MTRresult = LowNDVIresult.and(masklayer);
    if (map_for_print == "yes") {
        var MTR_vectors = MTRresult.reduceToVectors(null, CountyGeo, 25);
    } else {
        var MTR_vectors = MTRresult.reduceToVectors(null, CountyBufferGeo, 25);
    }
    var MTR_Area = MTR_vectors.map(MineArea);

    LargeMTR_list[NDVI_Year] = MTR_Area.filterMetadata('area', 'greater_than', minMTRsize);

/*
Subtract the active mining layer from the buffered communities 
in order to calculate the unmined area within a 1-mile radius 
of each community. Then run functions to calculate 
the nearest distance to active mining and area within a 1-mile 
radius that is NOT classified as active mining
*/

    var flatMTR = ee.Feature(LargeMTR_list[NDVI_Year].geometry(25)); 
    var NoMTRwithinMile = bufferedPlaces.map( differ );
    areas_list[NDVI_Year] = NoMTRwithinMile.map( area_er ).sort('FEATURE_NAME', true);
    distances_list[NDVI_Year] = FilteredPopPlaces.map(dist_er).sort("FEATURE_NAME", true);

    Map.addLayer(LargeMTR_list[NDVI_Year], {color: 'FF0000'}, 'Active Surface Mining: ' + NDVI_Year);
}

var areas_FC = ee.FeatureCollection(areas_list[start_year]);
var distances_FC = ee.FeatureCollection(distances_list[start_year]);
var LargeMTR_FC = ee.FeatureCollection(LargeMTR_list[start_year]);

for(var loop_Year = start_year + 3; loop_Year <= end_year; loop_Year = loop_Year +3){
  areas_FC = areas_FC.merge(areas_list[loop_Year]);
  distances_FC = distances_FC.merge(distances_list[loop_Year]);
  LargeMTR_FC = LargeMTR_FC.merge(LargeMTR_list[loop_Year]);
}

print(areas_FC.getDownloadURL('csv','year,area,FEATURE_ID,FEATURE_NAME,county', 'ACAR_' + CountySelect + '_' + start_year + '-' + end_year + '_area_' + maskBufferSize));
print(distances_FC.getDownloadURL('csv','year,dist,FEATURE_ID,FEATURE_NAME,county', 'ACAR_' + CountySelect + '_' + start_year + '-' + end_year + '_distance_' + maskBufferSize));
print(LargeMTR_FC.getDownloadURL('kml', null, 'ACAR_' + CountySelect + '_' + start_year + '-' + end_year +  '_ActiveMining_' + maskBufferSize));

// Add layers to map

Map.centerObject(FlatCounty, 11);

//Map.addLayer(clip_composite, {'bands':['B3', 'B2', 'B1'], min:0, max:0.25}, NDVI_Year + ' Greenest Pixel');
Map.addLayer(gp_ndvi,{palette: 'FFFFFF, CE7E45, DF923D, F1B555, FCD163, 99B718, 74A901, 66A000, 529400, 3E8601, 207401, 056201, 004C00, 023B01, 012E01, 011D01, 011301'}, NDVI_Year + ' Greenest Pixel NDVI');
//Map.addLayer(LowNDVIresult, {palette: '0000FF'}, 'Low NDVI areas');
//Map.addLayer(MTRresult, {palette: 'FF00FF'}, 'Unsieved Surface Mining');
Map.addLayer(mask_result, {palette: '000000'}, 'Original Mask');
//Map.addLayer(masklayer, {palette: '000000'}, 'Reverse Mask');
//Map.addLayer(LargeMTR, {color: 'FF0000'}, 'Active Surface Mining');
//Map.addLayer(LargeMTR_FC, {color: 'FF0000'}, 'Active Surface Mining');
//Map.addLayer(NoMTRwithinMile, {color:'b0b0b0'}, "NoMTRwithinMile");

